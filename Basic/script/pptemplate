#!perl -w

use strict;
use warnings;
use File::Basename;
use File::Path qw(make_path);

sub names {
  my ($module) = @_;
  my $pdname = 'lib/'.($module =~ s#::#/#gr) . '.pd';
  my $dir = $module =~ s#::#-#gr;
  return ($module, $pdname, $dir);
}

sub pdtmpl {
  my ($module) = @_;
  <<EOF;
# template auto generated by pptemplate
# uncomment commands, copy and fill in as needed
# see also the PDL::PP manpage

use strict;
use warnings;

our \$VERSION = '0.001';
pp_setversion(\$VERSION);

{ no warnings 'once'; # pass info back to Makefile.PL
#\$PDL::Core::Dev::EXTRAS{\$::PDLMOD}{OBJECT} .= join '', map " \$::PDLBASE/\$_\\$(OBJ_EXT)", qw(fftn);
#\$PDL::Core::Dev::EXTRAS{\$::PDLMOD}{DEFINE} .= qq{ -DFFT_FLOAT -DFFT_DOUBLE -DFFT_LDOUBLE};
#\$PDL::Core::Dev::EXTRAS{\$::PDLMOD}{INC} .= qq{ "-I\$::PDLBASE"};
}

# pp_bless('');       # package namespace of pp_def'ed functions
		      # defaults to 'PDL'

# pp_add_boot('');    # code to add to the XS boot section

# pp_addhdr('');      # add C code to the section preceding
		      # the first MODULE keyword

pp_addpm({At=>'Top'}, <<'EOPM');
use strict;
use warnings;

=head1 NAME

$module - new PDL module to clutter up CPAN

=head1 SYNOPSIS

  use $module;
  # FILL THIS IN

=head1 DESCRIPTION

This will change the world.

=cut
EOPM

# pp_add_exported(''); # add the list of functions
                       # to the list of exported functions

# pp_addxs('');        # add plain XS code to the XS section

# pp_add_isa(qw//);    # inheritance business: add arglist to modules \@ISA

pp_def('myinc',
  Pars => 'a(); [o]b()',
  Code => '\$b() = \$a() + 1;',
);

pp_done();  # you will need this to finish pp processing
EOF
}

sub pdMakefile {
  my ($module, $pdname) = @_;
  return <<EOM;
use strict;
use warnings;
use ExtUtils::MakeMaker;
use PDL::Core::Dev;

WriteMakefile(
  NAME                => '$module',
  AUTHOR              => 'A.U.Thor  <author\@example.com>',
  VERSION_FROM        => '$pdname',
  MIN_PERL_VERSION => '5.016',
  LICENSE=> 'perl',
  PREREQ_PM => {
    'PDL::Basic'  => '2.096', # deep mode
  },
  CONFIGURE_REQUIRES => {
    'PDL::Basic'  => '2.096',
  },
  BUILD_REQUIRES => {
    'PDL::Basic'  => '2.096',
  },
  TEST_REQUIRES => {
    'Test::More' => '0.88', # done_testing
    'Test::PDL' => '0.21',
  },
);

{
my \@pd_srcs;
package MY; # so that "SUPER" works right
sub init_PM {
  my (\$self) = \@_;
  \$self->SUPER::init_PM;
  \@pd_srcs = ::pdlpp_eumm_update_deep(\$self);
}
sub postamble { ::pdlpp_postamble(\@pd_srcs) }
}
EOM
}

sub usage {
  require File::Basename;
  die "usage: @{[File::Basename::basename $0]} modulename\n";
}

usage if !@ARGV;
my ($module, $pdname, $dir) = names $ARGV[0];

die "$dir already exists; move out of the way if you want to proceed"
  if -d $dir;
mkdir $dir or die "$dir: $!";
chdir $dir or die "$dir: $!";

my $pd_dir = dirname $pdname;
make_path $pd_dir; die "$pd_dir not created" if !-d $pd_dir;
open my $pdfl, ">", $pdname or die "$pdname: $!";
print $pdfl pdtmpl($module);
close $pdfl;

open my $mkfl, ">", 'Makefile.PL' or die "Makefile.PL: $!";
print $mkfl pdMakefile($module, $pdname);
close $mkfl;

mkdir 't' or die "t: $!";
open my $tfl, '>', 't/basic.t' or die "t/basic.t: $!";
print $tfl <<EOF;
use strict;
use warnings;
use PDL::LiteF;
use Test::More;
use Test::PDL;
use $module;

is_pdl pdl(3,5)->myinc, pdl(4,6);

done_testing;
EOF
close $tfl;

=head1 NAME

pptemplate - script to generate Makefile.PL and PP file skeleton

=head1 SYNOPSIS

  # generate Makefile.PL and mymodule.pd in PDL-MyModule
  pptemplate PDL::MyModule;

=head1 DESCRIPTION

The B<pptemplate> script is the easiest way to start a new module
for PDL that contains PP code (see also L<PDL::PP>). The usage is simply

  pptemplate modulename;

As a result pptemplate will generate a perl Makefile for the new
module (F<Makefile.PL>) that contains the minimal structure to
generate a module from PP code and also a skeleton file
for your new module.

The file will be called F<mymod.pd> if you called C<pptemplate> as

  pptemplate PDL::CleverAlgs::Mymod;

I suppose you can work out the naming rule C<;)>. If not resort to
experimentation or the source code.

C<pptemplate> will stop if the directory to be created already exists,
to avoid accidents. Move it out of the way if you really want to scrap it.

As of 2.096, the "internal mode" of this script has been removed,
and it creates the files using the new "deep mode". This is because
the earlier practice of incorporating vast numbers of modules into
the main PDL distribution has been rethought due to the problems
it causes. Use this script to make it easy to create new CPAN-distributed
PDL modules.

=head1 BUGS

Feedback and bug reports are welcome.

=head1 COPYRIGHT

Copyright (c) 2001, Christian Soeller. All Rights Reserved.
This module is free software. It may be used, redistributed
and/or modified under the same terms as PDL itself
(see L<http://pdl.perl.org>).

=cut
