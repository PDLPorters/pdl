#!/usr/bin/env perl

use strict;
use warnings;
use File::Basename;
use File::Path qw(make_path);

sub names {
  my ($module) = @_;
  my $pdname = 'lib/'.($module =~ s#::#/#gr) . '.pd';
  my $dir = $module =~ s#::#-#gr;
  return ($module, $pdname, $dir);
}

sub pdtmpl {
  my ($module) = @_;
  <<EOF =~ s/^!=/=/gmr;
# template auto generated by pptemplate
# uncomment commands, copy and fill in as needed
# see also the PDL::PP manpage

use strict;
use warnings;

our \$VERSION = '0.001';
pp_setversion(\$VERSION);

{ no warnings 'once'; # pass info back to Makefile.PL
#\$PDL::Core::Dev::EXTRAS{\$::PDLMOD}{OBJECT} .= join '', map " \$::PDLBASE/\$_\\$(OBJ_EXT)", qw(fftn);
#\$PDL::Core::Dev::EXTRAS{\$::PDLMOD}{DEFINE} .= qq{ -DFFT_FLOAT -DFFT_DOUBLE -DFFT_LDOUBLE};
#\$PDL::Core::Dev::EXTRAS{\$::PDLMOD}{INC} .= qq{ "-I\$::PDLBASE"};
}

# pp_bless('');       # package namespace of pp_def'ed functions
		      # defaults to 'PDL'

# pp_add_boot('');    # code to add to the XS boot section

# pp_addhdr('');      # add C code to the section preceding
		      # the first MODULE keyword

pp_addpm({At=>'Top'}, <<'EOPM');
use strict;
use warnings;

!=head1 NAME

$module - new PDL module to clutter up CPAN

!=head1 SYNOPSIS

  use $module;
  # FILL THIS IN

!=head1 DESCRIPTION

This will change the world.

!=cut
EOPM

# pp_add_exported(''); # add the list of functions
                       # to the list of exported functions

# pp_addxs('');        # add plain XS code to the XS section

# pp_add_isa(qw//);    # inheritance business: add arglist to modules \@ISA

pp_def('myinc',
  Pars => 'a(); [o]b()',
  Code => '\$b() = \$a() + 1;',
);

pp_done();  # you will need this to finish pp processing
EOF
}

sub pdMakefile {
  my ($module, $pdname) = @_;
  return <<EOM;
use strict;
use warnings;
use ExtUtils::MakeMaker;
use PDL::Core::Dev;

WriteMakefile(
  NAME                => '$module',
  AUTHOR              => 'A.U.Thor  <author\@example.com>',
  VERSION_FROM        => '$pdname',
  MIN_PERL_VERSION => '5.016',
  LICENSE=> 'perl',
  PREREQ_PM => {
    'PDL'  => '2.096', # deep mode
  },
  CONFIGURE_REQUIRES => {
    'PDL'  => '2.096',
  },
  BUILD_REQUIRES => {
    'PDL'  => '2.096',
  },
  TEST_REQUIRES => {
    'Test::More' => '0.88', # done_testing
    'Test::PDL' => '0.21',
  },
);

{
my \@pd_srcs;
package MY; # so that "SUPER" works right
sub init_PM {
  my (\$self) = \@_;
  \$self->SUPER::init_PM;
  \@pd_srcs = ::pdlpp_eumm_update_deep(\$self);
}
sub postamble { ::pdlpp_postamble(\@pd_srcs) }
}
EOM
}

sub pdManifest {
  my ($pdname) = @_;
  my $pd_dir = dirname $pdname;
  return <<"END_OF_MANIFEST";
$pdname
Makefile.PL
MANIFEST
MANIFEST.SKIP
t/basic.t
END_OF_MANIFEST
}

sub pdManifest_skip {
  my ($pdname,$dir) = @_;
  my $pd_dir = dirname $pdname;
  my $pm_name = $pdname =~ s/\.pd$/.pm/r;
  return <<"SKIP_PROJECT" . <<'SKIP_GENERAL';
# This project's temporary files
$pm_name
$pd_dir/.*-pp-.*
$pd_dir/.*\\.bs\$
$pd_dir/.*\\.c\$
$pd_dir/.*\\.o\$
$pd_dir/.*\\.xs\$
$dir-.*\\.tar\\.gz
SKIP_PROJECT

# Version control
^.git

# Avoid Makemaker generated and utility files
^Makefile$
\bMANIFEST\.bak
\bblib/
\bMakeMaker-\d
\bpm_to_blib\.ts$
\bpm_to_blib$
\bblibdirs\.ts$         # 6.18 through 6.25 generated this
^MYMETA

# Avoid temp and backup files.
~$
\.old$
\#$
\b\.#
\.bak$
\.swp$
SKIP_GENERAL
}

sub pdGitignore {
  my ($pdname,$dir) = @_;
  my $base_name = $pdname =~ s/\.pd$//r;
  return <<"GIT_PROJECT" . <<'GIT_GENERAL';
# This project's temporary files
$base_name.pm
*-pp-*.c
$base_name.bs
$base_name.c
$base_name.o
$base_name.xs
$dir-*.tar.gz
GIT_PROJECT

# ExtUtil::MakeMaker temporary files
/blib
/Makefile
/MANIFEST.bak
/Makefile.old
/MYMETA.*
/pm_to_blib
GIT_GENERAL
}

sub usage {
  require File::Basename;
  die "usage: @{[File::Basename::basename $0]} modulename\n";
}

usage if !@ARGV;
my ($module, $pdname, $dir) = names $ARGV[0];

die "$dir already exists; move out of the way if you want to proceed"
  if -d $dir;
mkdir $dir or die "$dir: $!";
chdir $dir or die "$dir: $!";

print "Setting up a template for '$module' in '$dir'\n";
my $pd_dir = dirname $pdname;
make_path $pd_dir; die "$pd_dir not created" if !-d $pd_dir;
open my $pdfl, ">", $pdname or die "$pdname: $!";
print $pdfl pdtmpl($module);
close $pdfl;

open my $mkfl, ">", 'Makefile.PL' or die "Makefile.PL: $!";
print $mkfl pdMakefile($module, $pdname);
close $mkfl;

open my $manifest, '>', 'MANIFEST'  or  die "MANIFEST: '$!'";
print $manifest pdManifest($pdname);
close $manifest;

open my $manifest_skip, '>', 'MANIFEST.SKIP'  or  die "MANIFEST.SKIP: '$!'";
print $manifest_skip pdManifest_skip($pdname,$dir);
close $manifest_skip;

open my $gitignore, '>', '.gitignore'  or  die ".gitignore: '$!'";
print $gitignore pdGitignore($pdname,$dir);
close $gitignore;

mkdir 't' or die "t: $!";
open my $tfl, '>', 't/basic.t' or die "t/basic.t: $!";
print $tfl <<EOF;
use strict;
use warnings;
use PDL::LiteF;
use Test::More;
use Test::PDL;
use $module;

is_pdl pdl(3,5)->myinc, pdl(4,6);

done_testing;
EOF
close $tfl;

=head1 NAME

pptemplate - script to generate Makefile.PL and PP file skeleton

=head1 SYNOPSIS

  # generate Makefile.PL and mymodule.pd in PDL-MyModule
  pptemplate PDL::MyModule;

=head1 DESCRIPTION

The B<pptemplate> script is the easiest way to start a new module
for PDL that contains PP code (see also L<PDL::PP>). The usage is simply

  pptemplate modulename;

As a result pptemplate will generate the usual directory structure you
would expect for a CPAN module: if you called C<pptemplate> as

  pptemplate PDL::CleverAlgs::Mymod;

Then you get the following files and directories:

  PDL-CleverAlgs-Mymod
  |-- lib
  |   |-- PDL
  |       |-- CleverAlgs
  |           |-- MyMod.pd
  |-- t
  |   |-- basic.t
  |-- Makefile.PL
  |   MANIFEST
  |   MANIFEST.SKIP
  |   .gitignore

Adapt F<MyMod.pd> to your needs and then you can build and test the
module as usual: From the directory F<PDL-CleverAlgs-Mymod>:

   $ perl Makefile.pl   # To create a Makefile
   $ make               # Build the module in blib
   $ make test          # Run the tests
   $ prove -vb          # ...or run the tests with prove

C<pptemplate> will stop if the directory to be created already exists,
to avoid accidents. Move it out of the way if you really want to scrap it.

The files F<MANIFEST>, F<MANIFEST.SKIP> and F<.gitignore> are for
bookkeeping: They avoid that temporary files created by building the
module end up in a git repository or a CPAN distrubution.

As of 2.096, the "internal mode" of this script has been removed,
and it creates the files using the new "deep mode". This is because
the earlier practice of incorporating vast numbers of modules into
the main PDL distribution has been rethought due to the problems
it causes. Use this script to make it easy to create new CPAN-distributed
PDL modules.

=head1 BUGS

Feedback and bug reports are welcome.

=head1 COPYRIGHT

Copyright (c) 2001, Christian Soeller. All Rights Reserved.
This module is free software. It may be used, redistributed
and/or modified under the same terms as PDL itself
(see L<http://pdl.perl.org>).

=cut
