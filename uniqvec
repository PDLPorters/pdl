=head2 uniqvec

=for ref

return all unique vectors out of a collection

  NOTE: If any vectors in the input piddle have NaN values
  they are returned at the end of the non-NaN ones.  This is
  because, by definition, NaN values never compare equal with
  any other value.

The unique vectors are returned in lexicographically sorted
ascending order.  The 0th dimension of the input PDL is treated
as a dimensional index within each vector, and the 1st and any higher
dimensions are taken to run across vectors.  The return value is always
2D; any structure of the input PDL (beyond using the 0th dimension 
for vector index) is lost.  

See also L<uniq|uniq> for a uniqe list of scalars; and
L<qsortvec|PDL::Ufunc/qsortvec> for sorting a list of vectors
lexicographcally.

=cut




=for bad

If a vector contains all bad values, it is ignored as in L<uniq|uniq>.
If some of the values are good, it is treated as a normal vector. For
example, [1 2 BAD] and [BAD 2 3] could be returned, but [BAD BAD BAD] 
could not.

=cut




sub PDL::uniqvec {
   my($pdl) = shift;
   return $pdl if $pdl->nelem==0;
   return $pdl->uniq->dummy(0) if ( $pdl->ndims<2 || $pdl->slice("(0)")->nelem<2 );  # slice isn't cheap but uniqvec isn't either

   # basically any($pdl->isNaN)
   # if ( &PDL::or($pdl!=$pdl) ) {  # use PDL::or since any() is in Ufunc, not Primitive
   #    # NaN handling for uniqvec not yet implemented (see uniq and uniqind for approach)
   #    barf("uniqvec: ERROR, NaN values not supported!\n  Do \$a .= \$a->where(\$a==\$a) to strip them out.\n");
   # }

   our $pdl2d = $pdl->mv(0,-1)->clump($pdl->ndims-1)->mv(-1,0);
   our $numnan   = ($pdl2d!=$pdl2d)->sumover;
   our $nonanind = ($pdl2d!=$pdl2d)->not->andover->which;         # find NaNs and all-BAD vector locations
   our $presrt = $pdl2d->mv(0,-1)->dice($nonanind)->mv(0,-1);     # remove vectors with NaN or all-BAD vals
   # use dice instead of nslice since qsortvec might be packing
   # the badvals to the front of the array instead of the end like
   # the docs say. If that is the case and it gets fixed, it won't
   # bust uniqvec. DAL 14-March 2006

   our $srt = $presrt->qsortvec->mv(0,-1);                        # BADs are sorted in this
   our $srtdice = $srt;
   $srtdice = $srt->dice($srt->mv(0,-1)->ngoodover->which) if ($PDL::Bad::Status && $srt->badflag);

   our $uniq;
   if ($srtdice->nelem > 0) {
      $uniq = ($srtdice != $srtdice->rotate(-1))->mv(0,-1)->orover->which;
   } else {
      $uniq = $srtdice->orover->which;
   }

   return $uniq->nelem==0 ? 
   $srtdice->slice("0,:")->mv(0,-1) :
   $srtdice->dice($uniq)->mv(0,-1);
}

1;
